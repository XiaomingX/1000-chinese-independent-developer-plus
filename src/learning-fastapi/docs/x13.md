以下内容将介绍如何在 FastAPI 中使用多个 Pydantic 模型，重点在于数据模型的定义、继承以及实际应用。我们将通过用户管理的例子，详细讲解不同场景下如何设计和使用数据模型。

## **多个 Pydantic 模型**

在实际开发中，我们经常需要处理同一个实体在不同状态下的数据。例如，用户注册时需要密码，但返回用户信息时不需要密码，存储在数据库中的密码需要加密。这时，我们可以使用多个 Pydantic 模型来表示用户的不同状态。

**用户模型的例子**

假设我们要创建一个用户管理系统，需要处理以下三种用户数据模型：

*   `UserIn`:  用户输入模型，包含注册时需要的用户名、密码、邮箱和姓名。
*   `UserOut`:  用户输出模型，包含返回给客户端的用户名、邮箱和姓名（不包含密码）。
*   `UserInDB`:  数据库存储模型，包含用户名、加密后的密码、邮箱和姓名。

以下是一个简单的示例代码：

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

class UserIn(UserBase):
    password: str

class UserOut(UserBase):
    pass

class UserInDB(UserBase):
    hashed_password: str

def fake_password_hasher(raw_password: str):
    # 实际场景中使用更安全的哈希算法，比如 bcrypt
    return "supersecret" + raw_password

def fake_save_user(user_in: UserIn):
    hashed_password = fake_password_hasher(user_in.password)
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    print("User saved! ..not really")
    return user_in_db

@app.post("/user/", response_model=UserOut)
async def create_user(user_in: UserIn):
    user_saved = fake_save_user(user_in)
    return user_saved
```

**代码解释**

1.  **UserBase**: 基础用户模型，包含公共字段（用户名、邮箱、姓名）。
2.  **UserIn**: 继承自 `UserBase`，添加了密码字段。
3.  **UserOut**: 继承自 `UserBase`，不包含密码字段，用于返回用户信息。
4.  **UserInDB**: 继承自 `UserBase`，包含加密后的密码字段。
5.  **fake\_password\_hasher**: 模拟密码加密函数，**实际应用中请使用安全的哈希算法**，比如 `bcrypt` 或 `argon2`。
6.  **fake\_save\_user**: 模拟保存用户到数据库的函数，将密码加密后存储。
7.  **create\_user**:  FastAPI 路由，接收 `UserIn` 模型作为输入，返回 `UserOut` 模型。

**实际应用场景**

*   **用户注册**：使用 `UserIn` 模型接收用户注册信息，包含密码。
*   **用户登录**：接收 `UserIn` 模型，验证用户名和密码。
*   **用户信息展示**：使用 `UserOut` 模型返回用户信息，不包含密码。
*   **数据库存储**：使用 `UserInDB` 模型存储用户信息，密码加密后存储。

## **Pydantic 模型的 `dict()` 方法和解包**

Pydantic 模型提供了一个 `.dict()` 方法，可以将模型转换为 Python 字典。这个方法在数据转换和传递时非常有用。

**示例**

```python
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
user_dict = user_in.dict()
print(user_dict)
# 输出: {'username': 'john', 'password': 'secret', 'email': 'john.doe@example.com', 'full_name': None}
```

**字典解包**

Python 允许使用 `**` 符号将字典解包，作为关键字参数传递给函数或类。

**示例**

```python
user_dict = {"username": "john", "password": "secret", "email": "john.doe@example.com", "full_name": None}
user_in_db = UserInDB(**user_dict, hashed_password="hashed_password")
print(user_in_db)
#输出: username='john' email='john.doe@example.com' full_name=None hashed_password='hashed_password'
```

## **减少代码重复**

在上面的例子中，`UserIn`、`UserOut` 和 `UserInDB` 模型有很多重复的字段。为了减少代码重复，我们可以使用继承。

1.  创建一个 `UserBase` 模型，包含公共字段。
2.  让 `UserIn`、`UserOut` 和 `UserInDB` 继承自 `UserBase`。
3.  在子类中只定义特有的字段。

这样做的好处是：

*   减少代码重复，提高代码可维护性。
*   方便修改公共字段，只需修改 `UserBase` 模型。
*   保证数据模型的一致性。

## **Union 类型**

使用 `typing.Union` 可以定义一个变量可以是多种类型之一。这在 API 返回不同类型的数据时非常有用。

**示例**

```python
from typing import Union
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class BaseItem(BaseModel):
    description: str
    type: str

class CarItem(BaseItem):
    type: str = "car"

class PlaneItem(BaseItem):
    type: str = "plane"
    size: int

items = {
    "item1": {"description": "All my friends drive a low rider", "type": "car"},
    "item2": {
        "description": "Music is my aeroplane, it's my aeroplane",
        "type": "plane",
        "size": 5,
    },
}

@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    return items[item_id]
```

在这个例子中，`/items/{item_id}` 接口返回的数据可以是 `PlaneItem` 或 `CarItem` 类型。

## **列表模型**

可以使用 `typing.List` (或者 Python 3.9+ 的 `list`) 来定义返回值为列表的接口。

**示例**

```python
from fastapi import FastAPI
from pydantic import BaseModel
from typing import List

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str

items = [
    {"name": "Foo", "description": "There comes my hero"},
    {"name": "Red", "description": "It's my aeroplane"},
]

@app.get("/items/", response_model=List[Item])
async def read_items():
    return items
```

在这个例子中，`/items/` 接口返回一个 `Item` 对象的列表。

## **返回任意字典**

如果事先不知道返回数据的字段名，可以使用 `typing.Dict` (或者 Python 3.9+ 的 `dict`) 来定义返回值为字典的接口。

**示例**

```python
from fastapi import FastAPI
from typing import Dict

app = FastAPI()

@app.get("/keyword-weights/", response_model=Dict[str, float])
async def read_keyword_weights():
    return {"foo": 2.3, "bar": 3.4}
```

在这个例子中，`/keyword-weights/` 接口返回一个字典，键为字符串类型，值为浮点数类型。

## **总结**

*   使用多个 Pydantic 模型来表示同一个实体在不同状态下的数据。
*   使用继承来减少代码重复。
*   使用 `typing.Union` 定义可以返回多种类型的接口。
*   使用 `typing.List` 定义返回列表的接口。
*   使用 `typing.Dict` 定义返回任意字典的接口。

通过以上方法，可以更灵活地设计和使用数据模型，提高代码的可维护性和可扩展性。