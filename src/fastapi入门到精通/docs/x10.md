## FastAPI WebSockets 详解与应用

WebSocket 是一种在客户端和服务器之间建立*持久连接*的技术，它允许服务器主动向客户端推送数据，而无需客户端发起请求。这使得实时通信成为可能，例如在线聊天、实时游戏、股票市场数据更新等。

### 1. 什么是 WebSockets?

传统的 HTTP 协议是*请求-响应*模式，客户端发起请求，服务器响应请求。如果服务器有新的数据需要发送给客户端，客户端必须先发起请求才能获取。而 WebSocket 协议则允许服务器主动推送数据给客户端，无需客户端的请求。

**对比 HTTP 和 WebSocket：**

| 特性     | HTTP                                   | WebSocket                               |
| -------- | -------------------------------------- | --------------------------------------- |
| 连接方式 | 短连接，每次请求建立新的连接             | 长连接，建立一次连接可以多次双向通信      |
| 通信方向 | 客户端发起请求，服务器响应               | 服务器可以主动向客户端推送数据            |
| 适用场景 | 静态内容、非实时数据                  | 实时性要求高的应用，如聊天、游戏、监控  |
| 协议类型 | 基于 HTTP，无状态协议                  | 独立协议，基于 TCP，有状态协议          |
| 头部信息   | 每次请求都包含头部，开销大               | 连接建立后头部信息较少，开销小            |

### 2. 如何在 FastAPI 中使用 WebSockets

#### **2.1 环境准备**

首先，确保安装了 `websockets` 库：

```bash
pip install websockets
```

#### **2.2 创建 WebSocket 端点**

在 FastAPI 应用中，使用 `@app.websocket()` 装饰器创建一个 WebSocket 端点。

```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var ws = new WebSocket("ws://localhost:8000/ws");
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")
```

**代码解释：**

*   `@app.websocket("/ws")`:  定义一个 WebSocket 端点，URL 为 `/ws`。
*   `websocket_endpoint(websocket: WebSocket)`:  处理 WebSocket 连接的函数。
*   `await websocket.accept()`:  接受客户端的 WebSocket 连接。
*   `await websocket.receive_text()`:  接收客户端发送的文本数据。
*   `await websocket.send_text()`:  向客户端发送文本数据。

#### **2.3 客户端连接**

可以使用 JavaScript 在浏览器中创建一个 WebSocket 客户端，连接到 FastAPI 应用的 WebSocket 端点。上述代码中的 html 变量，包含了 JavaScript 客户端代码，其主要功能为：

*   `var ws = new WebSocket("ws://localhost:8000/ws")`: 创建 WebSocket 对象，连接到服务器的 `/ws` 端点。
*   `ws.onmessage = function(event)`:  定义接收到消息时的处理函数，将消息显示在页面上。
*   `ws.send(input.value)`:  发送消息到服务器。

#### **2.4 运行**

将代码保存为 `main.py`，然后运行 FastAPI 应用：

```bash
fastapi dev main.py
```

在浏览器中打开 `http://localhost:8000`，即可看到聊天界面。

### 3. WebSocket 高级用法

#### **3.1 依赖注入**

WebSocket 端点也可以使用 FastAPI 的依赖注入系统，例如获取 Cookie、Header、Query 参数等。

```python
from typing import Annotated

from fastapi import (
    Cookie,
    Depends,
    FastAPI,
    Query,
    WebSocket,
    WebSocketException,
    status,
)
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <form action="" onsubmit="sendMessage(event)">
            <label>Item ID: <input type="text" id="itemId" autocomplete="off" value="foo"/></label>
            <label>Token: <input type="text" id="token" autocomplete="off" value="some-key-token"/></label>
            <button onclick="connect(event)">Connect</button>
            <hr>
            <label>Message: <input type="text" id="messageText" autocomplete="off"/></label>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
        var ws = null;
            function connect(event) {
                var itemId = document.getElementById("itemId")
                var token = document.getElementById("token")
                ws = new WebSocket("ws://localhost:8000/items/" + itemId.value + "/ws?token=" + token.value);
                ws.onmessage = function(event) {
                    var messages = document.getElementById('messages')
                    var message = document.createElement('li')
                    var content = document.createTextNode(event.data)
                    message.appendChild(content)
                    messages.appendChild(message)
                };
                event.preventDefault()
            }
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


async def get_cookie_or_token(
    websocket: WebSocket,
    session: Annotated[str | None, Cookie()] = None,
    token: Annotated[str | None, Query()] = None,
):
    if session is None and token is None:
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    return session or token


@app.websocket("/items/{item_id}/ws")
async def websocket_endpoint(
    *,
    websocket: WebSocket,
    item_id: str,
    q: int | None = None,
    cookie_or_token: Annotated[str, Depends(get_cookie_or_token)],
):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(
            f"Session cookie or query token value is: {cookie_or_token}"
        )
        if q is not None:
            await websocket.send_text(f"Query parameter q is: {q}")
        await websocket.send_text(f"Message text was: {data}, for item ID: {item_id}")
```

**代码解释：**

*   `@app.websocket("/items/{item_id}/ws")`:  定义一个 WebSocket 端点，URL 包含路径参数 `item_id`。
*   `cookie_or_token: Annotated[str, Depends(get_cookie_or_token)]`:  使用 `Depends` 获取依赖注入的值，这里 `get_cookie_or_token` 函数会检查 Cookie 或 Query 参数中是否包含 `session` 或 `token`，如果都没有则抛出 `WebSocketException` 异常。

#### **3.2 处理连接断开**

当客户端断开连接时，`await websocket.receive_text()` 会抛出 `WebSocketDisconnect` 异常，可以捕获该异常并进行处理。

```python
from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>Chat</title>
    </head>
    <body>
        <h1>WebSocket Chat</h1>
        <h2>Your ID: <span id="ws-id"></span></h2>
        <form action="" onsubmit="sendMessage(event)">
            <input type="text" id="messageText" autocomplete="off"/>
            <button>Send</button>
        </form>
        <ul id='messages'>
        </ul>
        <script>
            var client_id = Date.now()
            document.querySelector("#ws-id").textContent = client_id;
            var ws = new WebSocket(`ws://localhost:8000/ws/${client_id}`);
            ws.onmessage = function(event) {
                var messages = document.getElementById('messages')
                var message = document.createElement('li')
                var content = document.createTextNode(event.data)
                message.appendChild(content)
                messages.appendChild(message)
            };
            function sendMessage(event) {
                var input = document.getElementById("messageText")
                ws.send(input.value)
                input.value = ''
                event.preventDefault()
            }
        </script>
    </body>
</html>
"""


class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def send_personal_message(self, message: str, websocket: WebSocket):
        await websocket.send_text(message)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)


manager = ConnectionManager()


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
```

**代码解释：**

*   `ConnectionManager` 类用于管理 WebSocket 连接，包括连接、断开连接、发送消息等。
*   在 `websocket_endpoint` 函数中，使用 `try...except` 捕获 `WebSocketDisconnect` 异常，并在异常处理中调用 `manager.disconnect` 和 `manager.broadcast` 函数，通知其他客户端有用户离开了聊天。

### 4. 实际应用案例

#### **4.1 在线聊天室**

WebSocket 最常见的应用场景之一是实现在线聊天室。用户可以实时发送和接收消息，无需刷新页面。

#### **4.2 实时数据监控**

可以使用 WebSocket 实时推送服务器的 CPU、内存使用率等数据，方便运维人员监控服务器状态。例如，每隔 1 秒钟，服务器向客户端推送一次 CPU 使用率数据。

```python
import asyncio
import psutil
from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

html = """
<!DOCTYPE html>
<html>
    <head>
        <title>CPU Monitor</title>
    </head>
    <body>
        <h1>CPU Usage: <span id="cpu-usage"></span>%</h1>
        <script>
            var ws = new WebSocket("ws://localhost:8000/ws");
            ws.onmessage = function(event) {
                document.getElementById('cpu-usage').textContent = event.data;
            };
        </script>
    </body>
</html>
"""


@app.get("/")
async def get():
    return HTMLResponse(html)


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    try:
        while True:
            cpu_usage = psutil.cpu_percent(interval=0.5)
            await websocket.send_text(str(cpu_usage))
            await asyncio.sleep(0.5)
    except WebSocketDisconnect:
        pass
```

**代码解释：**

*   `psutil.cpu_percent(interval=0.5)`:  获取 CPU 使用率，每隔 0.5 秒更新一次。
*   `await asyncio.sleep(0.5)`:  暂停 0.5 秒，避免 CPU 使用率更新过快。

#### **4.3 实时游戏**

WebSocket 也常用于开发实时游戏，例如在线对战游戏。客户端通过 WebSocket 向服务器发送游戏操作，服务器更新游戏状态并推送给所有客户端。

### 5. 注意事项

*   WebSocket 连接是*有状态*的，服务器需要维护每个客户端的连接信息。
*   WebSocket 连接是*长连接*，需要注意处理连接断开的情况，避免资源泄漏。
*   在高并发场景下，需要考虑 WebSocket 服务器的性能和扩展性。可以使用负载均衡、消息队列等技术来提高 WebSocket 服务器的吞吐量和可靠性。

通过本文的介绍，相信你已经对 FastAPI 中使用 WebSockets 有了初步的了解。希望你能利用 WebSocket 技术，开发出更多有趣的应用。